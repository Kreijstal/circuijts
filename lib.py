# -*- coding: utf-8 -*-
"""Untitled13.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AcbJHieZMEqC2XTuEwej6ORt9WnY-byO
"""

import re

class ProtoCircuitParser:
    def __init__(self):
        self.parsed_statements = []
        self.errors = []

        # Regex patterns
        self.COMMENT_RE = re.compile(r';.*$')
        self.DECLARATION_RE = re.compile(r'^\s*([a-zA-Z_][a-zA-Z0-9_]*)\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*$') # Type InstanceName
        self.NODE_RE = re.compile(r'^\(([a-zA-Z0-9_.]+)\)$') # Allows dot for Dev.Term
        self.COMPONENT_NAME_RE = re.compile(r'^[a-zA-Z_][a-zA-Z0-9_]*$') # For instance names, type names, terminal names
        self.SOURCE_RE = re.compile(r'^([a-zA-Z_][a-zA-Z0-9_]*)\s*\((-\+|\+-)\)$') # InstanceName (Polarity)
        self.NAMED_CURRENT_RE = re.compile(r'^(->|<-)([a-zA-Z_][a-zA-Z0-9_]*)$')
        self.CONTROLLED_SOURCE_RE = re.compile(r'^(.*?)\s*\((->|<-)\)$')

        self.COMPONENT_BLOCK_RE = re.compile(r'^([a-zA-Z_][a-zA-Z0-9_]*)\s*{\s*(.*?)\s*}$', re.DOTALL)
        self.COMPONENT_BLOCK_ASSIGN_RE = re.compile(r'([a-zA-Z_][a-zA-Z0-9_]*)\s*:\s*\(([a-zA-Z0-9_.]+)\)')
        self.DIRECT_ASSIGN_RE = re.compile(r'^\s*\(([a-zA-Z0-9_.]+)\)\s*:\s*\(([a-zA-Z0-9_.]+)\)\s*$')

    def _parse_element(self, element_str, line_num, context="series"):
        element_str = element_str.strip()
        match_node = self.NODE_RE.match(element_str)
        if match_node:
            node_name = match_node.group(1)
            if not re.fullmatch(r'[a-zA-Z_][a-zA-Z0-9_]*(\.[a-zA-Z_][a-zA-Z0-9_]*)?', node_name):
                 self.errors.append(f"L{line_num}: Invalid node name format '{node_name}' in '{element_str}'. Expected (name) or (Device.Terminal).")
                 return {"type": "error", "message": f"Invalid node name format: {node_name}"}
            return {"type": "node", "name": node_name}

        match_source = self.SOURCE_RE.match(element_str)
        if match_source:
            name, polarity = match_source.groups()
            if not self.COMPONENT_NAME_RE.fullmatch(name):
                self.errors.append(f"L{line_num}: Invalid source instance name format '{name}'. Must be alphanumeric, starting with letter/underscore.")
                return {"type": "error", "message": f"Invalid source instance name format: {name}"}
            return {"type": "source", "name": name, "polarity": polarity} # Name is instance name

        if context == "series": # Named currents only allowed in series context by this parser logic
            match_current = self.NAMED_CURRENT_RE.match(element_str)
            if match_current:
                direction, name = match_current.groups()
                if not self.COMPONENT_NAME_RE.fullmatch(name):
                     self.errors.append(f"L{line_num}: Invalid current identifier '{name}'. Must be alphanumeric, starting with letter/underscore.")
                     return {"type": "error", "message": f"Invalid current identifier: {name}"}
                return {"type": "named_current", "direction": direction, "name": name}

        if context == "parallel": # Controlled/Noise sources only in parallel context
            match_cs = self.CONTROLLED_SOURCE_RE.match(element_str)
            if match_cs:
                expr_id = match_cs.group(1).strip()
                direction = match_cs.group(2)
                if not expr_id:
                    self.errors.append(f"L{line_num}: Empty expression/id for controlled/noise source in parallel block: '{element_str}'")
                    return {"type": "error", "message": "Empty expression/id for source"}
                if '*' in expr_id: # Assume VCCS if '*' is present
                    return {"type": "controlled_source", "expression": expr_id, "direction": direction}
                else: # Assume noise_id
                    if not self.COMPONENT_NAME_RE.fullmatch(expr_id):
                        self.errors.append(f"L{line_num}: Invalid noise source identifier '{expr_id}'. Must be alphanumeric, starting with letter/underscore.")
                        return {"type": "error", "message": f"Invalid noise source id: {expr_id}"}
                    return {"type": "noise_source", "id": expr_id, "direction": direction}

        # Default to component instance name if nothing else matches
        if self.COMPONENT_NAME_RE.fullmatch(element_str): # Check if it's a valid identifier
            return {"type": "component", "name": element_str} # Name is instance name

        self.errors.append(f"L{line_num}: Unrecognized or malformed element '{element_str}' in {context} context.")
        return {"type": "error", "message": f"Unrecognized element: {element_str}"}

    def _parse_parallel_block_content(self, content_str, line_num):
        elements_str_raw = content_str.split('||')
        parsed_elements = []
        if not any(s.strip() for s in elements_str_raw) and content_str:
             self.errors.append(f"L{line_num}: Parallel block `[{content_str}]` appears to have malformed separators or empty elements.")

        for i, el_str_raw in enumerate(elements_str_raw):
            el_str = el_str_raw.strip()
            if not el_str:
                if len(elements_str_raw) > 1 and i < len(elements_str_raw) -1 :
                     self.errors.append(f"L{line_num}: Empty element due to '|| ||' or trailing '||' in parallel block: `[{content_str}]`.")
                elif len(elements_str_raw) == 1:
                     self.errors.append(f"L{line_num}: Parallel block `[{content_str}]` is empty or contains only whitespace.")
                continue
            parsed_el = self._parse_element(el_str, line_num, context="parallel")
            parsed_elements.append(parsed_el)
        return parsed_elements

    def parse_line(self, line_text, line_num):
        line = self.COMMENT_RE.sub('', line_text).strip()
        if not line:
            return

        # 1. Check for Component Declaration
        match_decl = self.DECLARATION_RE.fullmatch(line)
        if match_decl:
            comp_type, inst_name = match_decl.groups()
            if not self.COMPONENT_NAME_RE.fullmatch(comp_type):
                self.errors.append(f"L{line_num}: Invalid component type format '{comp_type}'. Must be alphanumeric, starting with letter/underscore.")
            if not self.COMPONENT_NAME_RE.fullmatch(inst_name):
                self.errors.append(f"L{line_num}: Invalid component instance name format '{inst_name}'. Must be alphanumeric, starting with letter/underscore.")
            self.parsed_statements.append({
                "type": "declaration", "line": line_num,
                "component_type": comp_type, "instance_name": inst_name
            })
            return

        # 2. Check for Component Connection Block
        match_comp_block = self.COMPONENT_BLOCK_RE.fullmatch(line)
        if match_comp_block:
            comp_name, assignments_str = match_comp_block.groups()
            if not self.COMPONENT_NAME_RE.fullmatch(comp_name):
                self.errors.append(f"L{line_num}: Invalid component instance name '{comp_name}' for connection block.")
            connections = []
            valid_assignments_found_in_block = False
            raw_assignments = assignments_str.split(',')
            for assign_part_raw in raw_assignments:
                assign_part = assign_part_raw.strip()
                if not assign_part: continue
                assign_match = self.COMPONENT_BLOCK_ASSIGN_RE.fullmatch(assign_part)
                if assign_match:
                    term, node = assign_match.groups()
                    if not self.COMPONENT_NAME_RE.fullmatch(term):
                        self.errors.append(f"L{line_num}: Invalid terminal name '{term}' in block for '{comp_name}'.")
                        continue
                    if not re.fullmatch(r'[a-zA-Z_][a-zA-Z0-9_]*(\.[a-zA-Z_][a-zA-Z0-9_]*)?', node):
                        self.errors.append(f"L{line_num}: Invalid node name format '{node}' for terminal '{term}' in block for '{comp_name}'.")
                        continue
                    connections.append({"terminal": term, "node": node})
                    valid_assignments_found_in_block = True
                else:
                    self.errors.append(f"L{line_num}: Malformed assignment '{assign_part}' in component block for '{comp_name}'. Expected 'Terminal:(NodeName)'.")
            if assignments_str.strip() and not valid_assignments_found_in_block:
                 self.errors.append(f"L{line_num}: Component block for '{comp_name}' ('{assignments_str.strip()}') had no valid 'Terminal:(NodeName)' assignments.")
            self.parsed_statements.append({
                "type": "component_connection_block", "line": line_num,
                "component_name": comp_name, "connections": connections,
                "_original_assignments_str": assignments_str
            })
            return

        # 3. Check for Series Connection
        if '--' in line:
            parts_str = []
            current_segment = ""
            bracket_level = 0
            for char_idx, char in enumerate(line):
                current_segment += char
                if char == '[': bracket_level += 1
                elif char == ']': bracket_level -= 1
                elif char == '-' and len(current_segment) > 1 and current_segment[-2] == '-' and bracket_level == 0:
                    parts_str.append(current_segment[:-2].strip())
                    current_segment = ""
            if current_segment.strip() or not parts_str: # Add last segment or if line is just e.g. "(N1)" which is not a series path
                parts_str.append(current_segment.strip())

            # Filter out empty strings that might result from splitting "A -- -- B"
            parts_str = [p for p in parts_str if p]

            if not parts_str and line.strip():
                 self.errors.append(f"L{line_num}: Series path line '{line}' could not be segmented. Check structure.")
                 self.parsed_statements.append({"type": "series_connection", "line": line_num, "path": [{"type": "error", "message": "Path segmentation failed"}], "_invalid_start": True})
                 return

            path = []
            # Check if path starts with a node
            if parts_str:
                first_element_str = parts_str[0].strip()
                first_part_parsed = self._parse_element(first_element_str, line_num, context="series")

                if first_part_parsed.get("type") != "node":
                    self.errors.append(f"L{line_num}: Series path must start with a node. Found '{first_element_str}' (parsed as type '{first_part_parsed.get('type', 'unknown')}').")
                    self.parsed_statements.append({"type": "series_connection", "line": line_num, "path": [first_part_parsed], "_invalid_start": True, "_path_str": line})
                    return
                else:
                    path.append(first_part_parsed)

                # Process remaining parts
                for part_str_orig in parts_str[1:]:
                    part_str = part_str_orig.strip() # Should be already stripped by splitter
                    if not part_str: continue # Should be filtered by `parts_str = [p for p in parts_str if p]`

                    if part_str.startswith('[') and part_str.endswith(']'):
                        content = part_str[1:-1].strip()
                        if not content:
                            self.errors.append(f"L{line_num}: Empty parallel block `[]` in series path.")
                            path.append({"type": "parallel_block", "elements": [], "_empty_block": True})
                            continue
                        parallel_elements = self._parse_parallel_block_content(content, line_num)
                        path.append({"type": "parallel_block", "elements": parallel_elements})
                    else:
                        path.append(self._parse_element(part_str, line_num, context="series"))

            self.parsed_statements.append({"type": "series_connection", "line": line_num, "path": path, "_path_str": line})
            return

        # 4. Check for Direct Node Assignment
        match_direct_assign = self.DIRECT_ASSIGN_RE.fullmatch(line)
        if match_direct_assign:
            src, tgt = match_direct_assign.groups()
            for node_name in [src, tgt]:
                 if not re.fullmatch(r'[a-zA-Z_][a-zA-Z0-9_]*(\.[a-zA-Z_][a-zA-Z0-9_]*)?', node_name):
                    self.errors.append(f"L{line_num}: Invalid node name format '{node_name}' in direct assignment.")
            self.parsed_statements.append({
                "type": "direct_assignment", "line": line_num,
                "source_node": src, "target_node": tgt
            })
            return

        self.errors.append(f"L{line_num}: Unrecognized line format or syntax error: '{line}'")

    def parse_text(self, text_content):
        self.parsed_statements = []
        self.errors = []
        lines = text_content.splitlines()
        for i, line_text in enumerate(lines):
            self.parse_line(line_text, i + 1)
        return self.parsed_statements, self.errors


class ProtoCircuitValidator:
    def __init__(self, parsed_statements):
        self.parsed_statements = parsed_statements
        self.errors = []
        self.VALID_COMPONENT_TYPES = {"R", "C", "L", "Nmos", "Pmos", "V", "I", "Opamp"}
        self.declared_component_types = {}  # InstanceName -> {"type": TypeStr, "line": line_num}
        self.explicitly_defined_nodes = set()
        self.node_connection_points = {}

    def _add_error(self, message, line_num=None):
        prefix = f"L{line_num}: Validation Error: " if line_num is not None else "Validation Error: "
        self.errors.append(f"{prefix}{message}")

    def _check_and_register_node(self, node_name, line_num, connected_to_info=""):
        if not re.fullmatch(r'[a-zA-Z_][a-zA-Z0-9_]*(\.[a-zA-Z_][a-zA-Z0-9_]*)?', node_name):
            self._add_error(f"Node name '{node_name}' has an invalid format.", line_num)
            return False # Invalid node format

        if '.' in node_name:
            dev_part, term_part = node_name.split('.', 1)
            if dev_part not in self.declared_component_types:
                self._add_error(f"Node '{node_name}' (terminal '{term_part}') refers to undeclared component instance '{dev_part}'. Declare '{dev_part}' first.", line_num)
                return False # Component not declared

        self.explicitly_defined_nodes.add(node_name)
        if connected_to_info:
            if node_name not in self.node_connection_points:
                self.node_connection_points[node_name] = []
            self.node_connection_points[node_name].append(connected_to_info)
        return True


    def validate(self):
        self.errors = []
        self.declared_component_types = {}
        self.explicitly_defined_nodes = set()
        self.node_connection_points = {}

        # --- Pass 1: Process Declarations ---
        for stmt in self.parsed_statements:
            if stmt['type'] == 'declaration':
                line_num = stmt.get('line')
                comp_type = stmt['component_type']
                inst_name = stmt['instance_name']

                if not re.fullmatch(r'[a-zA-Z_][a-zA-Z0-9_]*', comp_type): # Parser also checks
                    self._add_error(f"Component type name '{comp_type}' in declaration has invalid format.", line_num)
                elif comp_type not in self.VALID_COMPONENT_TYPES:
                    self._add_error(f"Unknown component type '{comp_type}' for instance '{inst_name}'. Valid types: {sorted(list(self.VALID_COMPONENT_TYPES))}", line_num)

                if not re.fullmatch(r'[a-zA-Z_][a-zA-Z0-9_]*', inst_name): # Parser also checks
                    self._add_error(f"Component instance name '{inst_name}' in declaration has invalid format.", line_num)

                if inst_name in self.declared_component_types:
                    prev_decl_line = self.declared_component_types[inst_name]['line']
                    self._add_error(f"Component instance '{inst_name}' re-declared. Previously declared on L{prev_decl_line}.", line_num)
                else:
                    self.declared_component_types[inst_name] = {"type": comp_type, "line": line_num}

        # --- Pass 2: Validate connections, component usage, and structure ---
        for stmt in self.parsed_statements:
            line_num = stmt.get('line')
            stmt_type = stmt['type']

            if stmt_type == 'declaration': # Already processed
                continue

            if stmt_type == 'component_connection_block':
                comp_name = stmt['component_name']
                original_assignments_str = stmt.get("_original_assignments_str", "").strip()

                if comp_name not in self.declared_component_types:
                    self._add_error(f"Component instance '{comp_name}' used in connection block but not declared.", line_num)
                    # Continue to check assignments for further errors, but connections involving this comp are invalid

                if not stmt['connections'] and original_assignments_str:
                    self._add_error(f"Block for '{comp_name}' ('{original_assignments_str}') had no valid 'Terminal:(Node)' assigns.", line_num)
                elif not stmt['connections'] and not original_assignments_str:
                    self._add_error(f"Component block for '{comp_name}' is empty.", line_num)

                for conn in stmt['connections']:
                    if not re.fullmatch(r'[a-zA-Z_][a-zA-Z0-9_]*', conn['terminal']): # Parser checks
                         self._add_error(f"Terminal name '{conn['terminal']}' for '{comp_name}' is invalid.", line_num)

                    # Register terminal as a node, and the connected node
                    # If comp_name itself is not declared, _check_and_register_node will handle M1.G part
                    self._check_and_register_node(f"{comp_name}.{conn['terminal']}", line_num, f"block assignment to ({conn['node']})")
                    self._check_and_register_node(conn['node'], line_num, f"{comp_name}.{conn['terminal']}")


            elif stmt_type == 'series_connection':
                if stmt.get("_invalid_start"): # Parser flagged path must start with node
                    # Error already logged by parser. Path structure is compromised.
                    continue

                path = stmt.get('path', [])
                if not path: # Should be caught by parser if line had '--' but no parts
                    self._add_error("Series connection path is empty after parsing.", line_num)
                    continue

                # Parser ensures first element is a node if _invalid_start is not set
                # So, path[0] should be a node.
                first_el_type = path[0].get('type')
                if first_el_type != 'node':
                    self._add_error(f"Series path does not start with a node (Validator final check). First element: {path[0]}", line_num)
                    continue

                is_structurally_valid_path = len(path) > 1 or (len(path) == 1 and path[0].get('type') not in ['node', 'error'])
                if not is_structurally_valid_path and path:
                    first_el_info = path[0].get('name', str(path[0]))
                    self._add_error(f"Series path '{stmt.get('_path_str', 'N/A')}' is too simple (e.g., just node '{first_el_info}'). Must connect points or include a component/source.", line_num)

                for i, item in enumerate(path):
                    item_type = item.get('type')
                    if item_type == 'error':
                        self._add_error(f"Path segment '{item.get('message', 'unknown error')}' from '{stmt.get('_path_str', 'N/A')}' error.", line_num)
                        continue

                    if item_type == 'node':
                        self._check_and_register_node(item['name'], line_num, f"series path '{stmt.get('_path_str', 'N/A')}'")

                    elif item_type == 'component':
                        comp_name = item['name']
                        if comp_name not in self.declared_component_types:
                            self._add_error(f"Component '{comp_name}' in series path '{stmt.get('_path_str', 'N/A')}' not declared.", line_num)

                    elif item_type == 'source':
                        source_name = item['name']
                        if source_name not in self.declared_component_types:
                            self._add_error(f"Source '{source_name}' in path '{stmt.get('_path_str', 'N/A')}' not declared.", line_num)
                        else:
                            decl_type = self.declared_component_types[source_name]['type']
                            if decl_type != 'V': # Assuming 'V' for voltage source
                                self._add_error(f"Instance '{source_name}' used as voltage source, but declared as '{decl_type}'. Expected 'V'.", line_num)

                    elif item_type == 'named_current':
                        if i == 0 or i == len(path) - 1:
                            self._add_error(f"Named current '{item['direction']}{item['name']}' must be between two elements.", line_num)
                        if i > 0 and path[i-1]['type'] in ['named_current', 'error']:
                             self._add_error(f"Named current '{item['direction']}{item['name']}' preceded by invalid element '{path[i-1]['type']}'.", line_num)
                        if i < len(path) -1 and path[i+1]['type'] in ['named_current', 'error']:
                             self._add_error(f"Named current '{item['direction']}{item['name']}' followed by invalid element '{path[i+1]['type']}'.", line_num)

                    elif item_type == 'parallel_block':
                        if item.get("_empty_block"):
                            self._add_error("Parallel block `[]` is empty.", line_num)
                        elif not item['elements']:
                             self._add_error("Parallel block `[...]` parsed with no valid elements.", line_num)
                        for pel in item['elements']:
                            pel_type = pel.get('type')
                            if pel_type == 'error':
                                self._add_error(f"Parallel block element error: {pel.get('message', 'unknown')}", line_num)
                            elif pel_type not in ['component', 'controlled_source', 'noise_source']:
                                self._add_error(f"Invalid type '{pel_type}' in parallel block. Allowed: component, controlled_source, noise_source.", line_num)
                            elif pel_type == 'component':
                                if pel['name'] not in self.declared_component_types:
                                    self._add_error(f"Component '{pel['name']}' in parallel block not declared.", line_num)

            elif stmt_type == 'direct_assignment':
                src_node, tgt_node = stmt['source_node'], stmt['target_node']
                if src_node == tgt_node:
                    self._add_error(f"Direct assignment connects node '{src_node}' to itself.", line_num)

                self._check_and_register_node(src_node, line_num, f"direct assignment to ({tgt_node})")
                self._check_and_register_node(tgt_node, line_num, f"direct assignment from ({src_node})")


        return self.errors


def summarize_circuit_elements(parsed_statements):
    explicit_nodes = set()
    declared_component_instances = set() # Store names of declared components
    implicit_nodes_generated = set()
    implicit_node_counter = 0

    for stmt in parsed_statements:
        stmt_type = stmt.get('type')

        if stmt_type == 'declaration':
            inst_name = stmt.get('instance_name')
            if inst_name: # Parser ensures format, validator checks for duplicates/type
                declared_component_instances.add(inst_name)

        elif stmt_type == 'component_connection_block':
            comp_name = stmt.get('component_name') # Assumed declared by validator
            for conn in stmt.get('connections', []):
                if conn.get('node'):
                    explicit_nodes.add(conn['node'])
                if comp_name and conn.get('terminal'): # comp_name validity checked by validator
                    explicit_nodes.add(f"{comp_name}.{conn['terminal']}")

        elif stmt_type == 'direct_assignment':
            if stmt.get('source_node'):
                explicit_nodes.add(stmt['source_node'])
            if stmt.get('target_node'):
                explicit_nodes.add(stmt['target_node'])

        elif stmt_type == 'series_connection':
            if stmt.get("_invalid_start"): # Path structure compromised, skip for implicit node analysis
                continue

            structural_path_elements = []
            for el in stmt.get('path', []):
                el_type = el.get('type')
                if el_type in ['node', 'component', 'source', 'parallel_block']:
                    structural_path_elements.append(el)
                # Explicit nodes from path are added below

            if not structural_path_elements:
                continue

            # Add explicit nodes from this path
            for el in structural_path_elements:
                if el.get('type') == 'node' and el.get('name'):
                    explicit_nodes.add(el['name'])

            # --- Implicit Node Generation for this series path ---
            # Path must start with a node, so no implicit node at the very start.
            # structural_path_elements[0] is guaranteed to be a node if _invalid_start is false.

            # Implicit node at the end if needed
            last_el_in_structural_path = structural_path_elements[-1]
            # An implicit node is needed at the end if the path has any non-node elements,
            # and the very last element itself is not a node.
            if last_el_in_structural_path.get('type') not in ['node']:
                implicit_node_counter += 1
                implicit_nodes_generated.add(f"_implicit_node_{implicit_node_counter}")

            # Implicit nodes between structural elements if neither is a node
            for i in range(len(structural_path_elements) - 1):
                el_current = structural_path_elements[i]
                el_next = structural_path_elements[i+1]

                # An implicit node is needed between two elements if they are directly connected
                # AND neither is an explicit node acting as the connection point.
                # R1 -- C1 needs implicit node. (N1) -- R1 needs no implicit node. R1 -- (N2) needs no implicit node.
                if el_current.get('type') not in ['node'] and \
                   el_next.get('type') not in ['node']:
                    implicit_node_counter += 1
                    implicit_nodes_generated.add(f"_implicit_node_{implicit_node_counter}")

    all_nodes_combined = explicit_nodes.union(implicit_nodes_generated)

    return {
        'num_total_nodes': len(all_nodes_combined),
        'node_list': sorted(list(all_nodes_combined)),
        'num_total_components': len(declared_component_instances),
        'component_list': sorted(list(declared_component_instances)), # These are from declarations
        'details': {
            'explicit_nodes': sorted(list(explicit_nodes)),
            'implicit_nodes': sorted(list(implicit_nodes_generated))
        }
    }

# Assume ProtoCircuitParser, ProtoCircuitValidator, and summarize_circuit_elements
# from the previous response are already defined in this environment.
# AND that the ProtoCircuitParser's COMPONENT_BLOCK_RE has had re.DOTALL removed.

test_circuit_description = """
; Test Circuit for Proto-Language Parser and Validator

; Declarations
V Vs1          ; Voltage Source
R R1           ; Resistor 1
Nmos M1        ; NMOS Transistor
R R2           ; Resistor 2
C C1           ; Capacitor C1
L L_test       ; Inductor for variety

; Component Connection Block for M1 (NOW SINGLE LINE)
M1 { G:(node_gate), S:(GND), D:(node_drain), B:(GND) }

; Series Connections
(node_input) -- Vs1 (-+) -- R1 -- (node_gate)
(node_drain) -- C1 -- (GND)

; Parallel Block example
(node_drain) -- [ R2 || C1 ] -- (GND)

; Controlled Source in Parallel Block
(node_drain) -- [ gm1*vgs1 (->) || R2 ] -- (GND)

; Named Current
(VDD) -- ->I_supply -- R2 -- (node_drain)

; Direct Assignment (Node Aliasing)
(Vout) : (node_drain)
(AnotherNode) : (M1.S)
"""

# --- The rest of the test script (parser instantiation, validation, etc.) remains the same ---

# 1. Initialize Parser
parser = ProtoCircuitParser() # Assumes the modified version without re.DOTALL

# 2. Parse the circuit description
print("--- Parsing Circuit ---")
parsed_statements, parser_errors = parser.parse_text(test_circuit_description)

if parser_errors:
    print("\nParser Errors Found:")
    for error in parser_errors:
        print(error)
else:
    print("Parsing successful, no errors.")

# 3. Initialize Validator
validator = ProtoCircuitValidator(parsed_statements)

# 4. Validate the parsed statements
print("\n--- Validating Circuit ---")
validation_errors = validator.validate()

if validation_errors:
    print("\nValidation Errors Found:")
    for error in validation_errors:
        print(error)
else:
    print("Validation successful, no errors.")

# 5. Summarize Circuit Elements
print("\n--- Circuit Summary ---")
summary = summarize_circuit_elements(parsed_statements)

print(f"Total Unique Nodes: {summary['num_total_nodes']}")
print(f"  Node List: {summary['node_list']}")
print(f"Total Declared Component Instances: {summary['num_total_components']}")
print(f"  Component Instance List: {summary['component_list']}")
print("\nDetails:")
print(f"  Explicit Nodes: {summary['details']['explicit_nodes']}")
print(f"  Implicit Nodes Generated: {summary['details']['implicit_nodes']}")

print(test_circuit_description)

def generate_proto_from_ast(parsed_statements):
    """
    Generates a Proto-Language circuit description string from its AST.

    Args:
        parsed_statements (list): A list of dictionaries, where each dictionary
                                  represents an AST node (a parsed statement).

    Returns:
        str: A string representing the reconstructed circuit description.
    """
    output_lines = []

    for stmt in parsed_statements:
        stmt_type = stmt.get('type')
        line_str = "" # Initialize line string for the current statement

        if stmt_type == 'declaration':
            line_str = f"{stmt['component_type']} {stmt['instance_name']}"

        elif stmt_type == 'component_connection_block':
            assignments = []
            for conn in stmt.get('connections', []):
                assignments.append(f"{conn['terminal']}:({conn['node']})")
            assignments_str = ", ".join(assignments)
            # Ensure space after '{' and before '}' as per typical spec examples
            line_str = f"{stmt['component_name']} {{ {assignments_str} }}"

        elif stmt_type == 'direct_assignment':
            line_str = f"({stmt['source_node']}):({stmt['target_node']})"

        elif stmt_type == 'series_connection':
            path_parts = []
            for item in stmt.get('path', []):
                item_type = item.get('type')
                if item_type == 'node':
                    path_parts.append(f"({item['name']})")
                elif item_type == 'component':
                    path_parts.append(item['name'])
                elif item_type == 'source':
                    path_parts.append(f"{item['name']} ({item['polarity']})")
                elif item_type == 'named_current':
                    path_parts.append(f"{item['direction']}{item['name']}")
                elif item_type == 'parallel_block':
                    elements_strs = []
                    for pel in item.get('elements', []):
                        pel_type = pel.get('type')
                        if pel_type == 'component':
                            elements_strs.append(pel['name'])
                        elif pel_type == 'controlled_source':
                            elements_strs.append(f"{pel['expression']} ({pel['direction']})")
                        elif pel_type == 'noise_source':
                            elements_strs.append(f"{pel['id']} ({pel['direction']})")
                        elif pel_type == 'error': # If AST can contain errors within blocks
                             elements_strs.append(f"<ERROR_IN_PARALLEL: {pel.get('message', 'Malformed element')}>")
                        else:
                             elements_strs.append(f"<UNKNOWN_PARALLEL_TYPE: {pel_type}>")

                    parallel_content = " || ".join(elements_strs)
                    # Ensure space after '[' and before ']'
                    path_parts.append(f"[ {parallel_content} ]")
                elif item_type == 'error': # If AST can contain errors within paths
                    path_parts.append(f"<ERROR_IN_PATH: {item.get('message', 'Malformed element')}>")
                else:
                    path_parts.append(f"<UNKNOWN_PATH_TYPE: {item_type}>")

            line_str = " -- ".join(path_parts)

        elif stmt_type == 'error': # If AST directly contains top-level error statements
            # This assumes an error statement in the AST would signify a line that couldn't be parsed
            # and we are just commenting it out or noting it.
            original_content = stmt.get('original_line_content', '') # if parser stores this
            message = stmt.get('message', 'Unknown parsing error')
            line_str = f"; ERROR IN ORIGINAL INPUT (L{stmt.get('line', '?')}): {message} -> {original_content}"

        else:
            # Fallback for any unknown statement types in the AST
            line_str = f"; UNKNOWN_AST_STATEMENT_TYPE: {stmt_type} - DATA: {stmt}"

        if line_str: # Add the reconstructed line if it's not empty
            output_lines.append(line_str)

    return "\n".join(output_lines)

print(generate_proto_from_ast(parsed_statements))

import networkx as nx

class DSU:
    """
    Disjoint Set Union (DSU) data structure, also known as Union-Find.
    Used here to manage equivalences between electrical net names.
    """
    def __init__(self):
        self.parent = {}
        self.num_sets = 0

    def add_set(self, item):
        """Ensures an item is part of the DSU, creating a new set if it's new."""
        if item not in self.parent:
            self.parent[item] = item
            self.num_sets += 1

    def find(self, item):
        """Finds the representative (root) of the set containing item, with path compression."""
        self.add_set(item) # Ensure item is in DSU before finding
        if self.parent[item] == item:
            return item
        self.parent[item] = self.find(self.parent[item])  # Path compression
        return self.parent[item]

    def union(self, item1, item2):
        """Merges the sets containing item1 and item2."""
        root1 = self.find(item1)
        root2 = self.find(item2)
        if root1 != root2:
            self.parent[root1] = root2  # Simple union: make root1 child of root2
            self.num_sets -= 1
            return True  # Union occurred
        return False # Already in the same set

    def get_all_canonical_representatives(self):
        """Returns a set of all canonical representatives."""
        return {self.find(item) for item in self.parent}

    def get_set_members(self, representative_item):
        """Returns all items belonging to the same set as representative_item."""
        canonical_rep = self.find(representative_item)
        return {item for item in self.parent if self.find(item) == canonical_rep}


def ast_to_graph(parsed_statements):
    """
    Converts a Proto-Language AST into a graph representation.

    Graph Nodes:
        - Component Instances (e.g., "R1", "M1"):
            Attributes: node_kind='component_instance', instance_type='R'/'Nmos'/etc.
        - Electrical Nets (e.g., "GND", "node_gate_canonical"):
            Attributes: node_kind='electrical_net'
            Net names are canonicalized using DSU.

    Graph Edges:
        - Connect a component instance node to an electrical net node.
        - Attribute: 'terminal' (e.g., 'G', 'D', 't1_series') indicating the
          component terminal involved in the connection.
    """
    G = nx.Graph()
    # Store component declarations: name -> {type, line, instance_node_name (same as name)}
    declared_components = {}
    # DSU to manage equivalence classes of electrical net names
    electrical_nets_dsu = DSU()

    implicit_node_idx = 0
    # For naming internally generated components like VCCS from parallel blocks
    internal_component_idx = 0

    # --- Pass 1: Process declarations and pre-populate DSU with known explicit net names ---
    for stmt in parsed_statements:
        stmt_type = stmt.get('type')
        if stmt_type == 'declaration':
            comp_type = stmt['component_type']
            inst_name = stmt['instance_name']
            # Store declaration info and add component instance node to graph
            declared_components[inst_name] = {'type': comp_type, 'line': stmt['line'], 'instance_node_name': inst_name}
            G.add_node(inst_name, node_kind='component_instance', instance_type=comp_type)

        # Pre-scan for all explicitly named nodes to add them to DSU early.
        # This helps in ensuring `find` always works on known items.
        elif stmt_type == 'component_connection_block':
            comp_name = stmt['component_name']
            for conn in stmt.get('connections', []):
                electrical_nets_dsu.add_set(conn['node']) # e.g., (node_gate)
                electrical_nets_dsu.add_set(f"{comp_name}.{conn['terminal']}") # e.g., (M1.G)
        elif stmt_type == 'direct_assignment':
            electrical_nets_dsu.add_set(stmt['source_node'])
            electrical_nets_dsu.add_set(stmt['target_node'])
        elif stmt_type == 'series_connection':
            for item in stmt.get('path', []):
                if item.get('type') == 'node':
                    electrical_nets_dsu.add_set(item['name'])

    # --- Pass 2: Process connections and build graph structure using canonical net names ---
    for stmt in parsed_statements:
        stmt_type = stmt.get('type')

        if stmt_type == 'declaration':
            continue # Already handled

        elif stmt_type == 'component_connection_block':
            comp_name = stmt['component_name']
            if comp_name not in declared_components:
                # This case should ideally be caught by a validator before this stage
                print(f"AST_TO_GRAPH_WARNING: Component '{comp_name}' in block not declared. Skipping.")
                continue

            comp_node_name = declared_components[comp_name]['instance_node_name']

            for conn in stmt.get('connections', []):
                terminal_name = conn['terminal']
                # Net name explicitly mentioned in the connection, e.g., "node_gate"
                explicit_net_name_in_connection = conn['node']
                # The device terminal itself is also an electrical net, e.g., "M1.G"
                device_terminal_as_net_name = f"{comp_name}.{terminal_name}"

                # Crucial: This block implies these two nets are the same.
                electrical_nets_dsu.union(device_terminal_as_net_name, explicit_net_name_in_connection)

                # Connect the component to the *canonical representative* of this unified net.
                canonical_net_name = electrical_nets_dsu.find(explicit_net_name_in_connection)
                if not G.has_node(canonical_net_name): # Ensure canonical net node exists
                    G.add_node(canonical_net_name, node_kind='electrical_net')

                G.add_edge(comp_node_name, canonical_net_name, terminal=terminal_name)

        elif stmt_type == 'direct_assignment':
            # These two net names are declared to be the same net.
            electrical_nets_dsu.union(stmt['source_node'], stmt['target_node'])

            # Ensure canonical nodes exist in graph (if not already from pre-scan or other stmts)
            for raw_node_name in [stmt['source_node'], stmt['target_node']]:
                canonical_name = electrical_nets_dsu.find(raw_node_name)
                if not G.has_node(canonical_name):
                    G.add_node(canonical_name, node_kind='electrical_net')

        elif stmt_type == 'series_connection':
            path = stmt.get('path', [])
            if not path or path[0].get('type') != 'node':
                # Parser should ensure paths start with a node.
                print(f"AST_TO_GRAPH_WARNING: Series path malformed or empty: {stmt.get('_path_str', 'N/A')}")
                continue

            # `current_attach_point` is always the canonical name of an electrical net.
            current_attach_point_canonical = electrical_nets_dsu.find(path[0]['name'])
            if not G.has_node(current_attach_point_canonical):
                 G.add_node(current_attach_point_canonical, node_kind='electrical_net')

            # Process elements from the second item onwards
            for i in range(1, len(path)):
                item = path[i]
                item_type = item.get('type')

                # Determine the `next_attach_point_canonical`
                # If the element after `item` is an explicit node, that's the next attach point.
                # Otherwise, if `item` is a connecting element (component, source, parallel_block),
                # an implicit node is needed.
                next_attach_point_canonical = None
                is_next_point_implicit = False

                if i + 1 < len(path) and path[i+1].get('type') == 'node':
                    next_attach_point_canonical = electrical_nets_dsu.find(path[i+1]['name'])
                elif item_type not in ['node', 'named_current', 'error']: # component, source, parallel_block
                    # This element needs a connection point after it, which will be implicit.
                    implicit_node_name_raw = f"_implicit_{implicit_node_idx}"
                    next_attach_point_canonical = electrical_nets_dsu.find(implicit_node_name_raw) # adds to DSU
                    is_next_point_implicit = True

                if next_attach_point_canonical and not G.has_node(next_attach_point_canonical):
                    G.add_node(next_attach_point_canonical, node_kind='electrical_net')

                # Handle the current item
                if item_type == 'component':
                    comp_name = item['name']
                    if comp_name not in declared_components: continue # Error already handled by validator ideally
                    comp_node_name = declared_components[comp_name]['instance_node_name']

                    # For 2-terminal components in series, use generic terminal names
                    G.add_edge(comp_node_name, current_attach_point_canonical, terminal='t1_series')
                    G.add_edge(comp_node_name, next_attach_point_canonical, terminal='t2_series')
                    current_attach_point_canonical = next_attach_point_canonical
                    if is_next_point_implicit: implicit_node_idx += 1

                elif item_type == 'source':
                    source_name = item['name']
                    if source_name not in declared_components: continue
                    source_node_name = declared_components[source_name]['instance_node_name']
                    polarity = item['polarity']

                    term_connected_to_current_attach = 'neg' if polarity == '(-+)' else 'pos'
                    term_connected_to_next_attach = 'pos' if polarity == '(-+)' else 'neg'

                    G.add_edge(source_node_name, current_attach_point_canonical, terminal=term_connected_to_current_attach)
                    G.add_edge(source_node_name, next_attach_point_canonical, terminal=term_connected_to_next_attach)
                    current_attach_point_canonical = next_attach_point_canonical
                    if is_next_point_implicit: implicit_node_idx += 1

                elif item_type == 'node': # This node becomes the new current_attach_point
                    current_attach_point_canonical = electrical_nets_dsu.find(item['name'])
                    # Ensure it exists in graph (should from pre-scan or previous step)
                    if not G.has_node(current_attach_point_canonical):
                         G.add_node(current_attach_point_canonical, node_kind='electrical_net')

                elif item_type == 'parallel_block':
                    parallel_start_node_canonical = current_attach_point_canonical
                    parallel_end_node_canonical = next_attach_point_canonical

                    for pel in item.get('elements', []):
                        element_node_name_in_graph = None
                        attrs = {'node_kind': 'component_instance'}

                        if pel['type'] == 'component':
                            if pel['name'] in declared_components:
                                element_node_name_in_graph = declared_components[pel['name']]['instance_node_name']
                            else: continue # Error
                        elif pel['type'] == 'controlled_source':
                            element_node_name_in_graph = f"_internal_cs_{internal_component_idx}"
                            attrs.update({'instance_type': 'controlled_source',
                                          'expression': pel['expression'], 'direction': pel['direction']})
                            internal_component_idx += 1
                        elif pel['type'] == 'noise_source':
                            element_node_name_in_graph = f"_internal_ns_{internal_component_idx}"
                            attrs.update({'instance_type': 'noise_source',
                                          'id': pel['id'], 'direction': pel['direction']})
                            internal_component_idx += 1

                        if element_node_name_in_graph:
                            if not G.has_node(element_node_name_in_graph):
                                G.add_node(element_node_name_in_graph, **attrs)
                            # Generic terminal names for elements within a parallel block
                            G.add_edge(element_node_name_in_graph, parallel_start_node_canonical, terminal='par_t1')
                            G.add_edge(element_node_name_in_graph, parallel_end_node_canonical, terminal='par_t2')

                    current_attach_point_canonical = parallel_end_node_canonical
                    if is_next_point_implicit: implicit_node_idx += 1

                elif item_type == 'named_current':
                    # Named currents are annotations on connections.
                    # This requires identifying the specific edge representing the "wire segment".
                    # For example, if path[i-1] was a component C, and it connected to
                    # current_attach_point_canonical via terminal T_prev of C.
                    # The edge (C_node, current_attach_point_canonical) with terminal=T_prev
                    # would get an attribute for this named current.
                    # This is advanced and depends on precise edge identification.
                    # For now, we'll skip adding it directly to the graph's structure
                    # but it could be added as an attribute to current_attach_point_canonical
                    # or the component connected *before* the current, if identifiable.
                    # print(f"AST_TO_GRAPH_INFO: Named current '{item['name']}' encountered, representation in graph TBD.")
                    pass


    # Optional: Create a "cleaner" graph where all net nodes are guaranteed to be their canonical names
    # This involves relabeling or creating a new graph.
    # For now, the existing graph G uses canonical names for edges, but some non-canonical
    # net nodes might exist if they were added before all unions were processed.
    # However, DSU lookups (`electrical_nets_dsu.find()`) ensure logical correctness.

    return G, electrical_nets_dsu

import networkx as nx



def get_preferred_net_name_for_reconstruction(canonical_net_name, dsu,
                                            known_significant_nodes=None,
                                            allow_implicit_if_only_option=False):
    if known_significant_nodes is None:
        known_significant_nodes = {'GND', 'VDD'}

    if not dsu or canonical_net_name not in dsu.parent:
        return canonical_net_name

    members = dsu.get_set_members(canonical_net_name)
    if not members: return canonical_net_name

    # Priority order for selecting a display name for a net
    # 1. User-defined, non-device terminal, non-significant common rail names
    user_named = sorted([m for m in members if not m.startswith("_implicit_") and '.' not in m and m not in known_significant_nodes])
    if user_named: return user_named[0]

    # 2. Known significant common rails
    sigs = sorted([m for m in members if m in known_significant_nodes])
    if sigs: return sigs[0]

    # 3. User-defined device terminals (e.g., M1.G)
    dev_terms = sorted([m for m in members if '.' in m and not m.startswith("_implicit_")])
    if dev_terms: return dev_terms[0]

    # 4. Any other non-implicit name (should be covered by user_named if exists)
    non_implicit = sorted([m for m in members if not m.startswith("_implicit_")])
    if non_implicit: return non_implicit[0]

    # 5. Implicit name, only if allowed or no other option
    if allow_implicit_if_only_option:
        return canonical_net_name # Which would be an implicit name if all others failed

    # Fallback: if we must return something and implicit is not allowed, this indicates an issue or an purely internal net.
    # For reconstruction, we might prefer to show its canonical form if it's an endpoint of a path.
    return canonical_net_name


def get_component_connectivity(graph, comp_name):
    """ Helper to find nets a component is connected to and via which terminals. """
    connections = {} # terminal_name -> canonical_net_name
    raw_connections = [] # list of {'term': ..., 'net_canon': ...} for ordering later if needed
    for _, neighbor_net_canonical, edge_data in graph.edges(comp_name, data=True):
        if graph.nodes[neighbor_net_canonical].get('node_kind') == 'electrical_net':
            terminal = edge_data.get('terminal')
            if terminal:
                connections[terminal] = neighbor_net_canonical
                raw_connections.append({'term': terminal, 'net_canon': neighbor_net_canonical})
    return connections, raw_connections


def graph_to_structured_ast(graph, dsu, remove_implicit_nodes=True):
    ast_statements = []
    processed_components = set() # Components included in any AST statement

    component_instance_nodes = [n for n, data in graph.nodes(data=True) if data.get('node_kind') == 'component_instance']
    comp_data_map = {name: graph.nodes[name] for name in component_instance_nodes}

    # 1. Emit Declarations
    for comp_name in component_instance_nodes:
        if not comp_name.startswith("_internal_"): # Internal VCCS/Noise are not declared
            ast_statements.append({
                'type': 'declaration',
                'component_type': comp_data_map[comp_name]['instance_type'],
                'instance_name': comp_name
            })

    # 2. Handle "Complex" Components (Multi-terminal like Nmos, or those with specific terminals)
    for comp_name in component_instance_nodes:
        if comp_name in processed_components or comp_name.startswith("_internal_"):
            continue

        instance_type = comp_data_map[comp_name]['instance_type']
        # Define complex types or condition (e.g. > 2 terminals or specific type)
        # For Nmos/Pmos, terminals G,D,S,B are specific. For R,C,L, V, I less so (t1/t2 or pos/neg).
        is_complex_type = instance_type in ["Nmos", "Pmos", "Opamp"] # Add others

        _, raw_conns = get_component_connectivity(graph, comp_name)

        if is_complex_type or len(raw_conns) > 2 : # Arbitrary threshold or specific type check
            connections_ast = []
            for conn_info in sorted(raw_conns, key=lambda x: x['term']): # Sort for consistent output
                connections_ast.append({
                    'terminal': conn_info['term'],
                    'node': get_preferred_net_name_for_reconstruction(conn_info['net_canon'], dsu, allow_implicit_if_only_option=True)
                })
            if connections_ast:
                ast_statements.append({
                    'type': 'component_connection_block',
                    'component_name': comp_name,
                    'connections': connections_ast
                })
                processed_components.add(comp_name)


    # 3. Iteratively find and emit series paths (incorporating parallel blocks)
    #    Start DFS from "significant" nets.
    all_nets_canonical = [n for n, data in graph.nodes(data=True) if data.get('node_kind') == 'electrical_net']

    # Prioritize starting from non-implicit, user-named nets
    potential_path_starts_canon = sorted(
        [n_canon for n_canon in all_nets_canonical
         if not get_preferred_net_name_for_reconstruction(n_canon, dsu).startswith('_implicit_')],
        key=lambda x: get_preferred_net_name_for_reconstruction(x, dsu) # Sort by preferred name for consistency
    )

    for start_net_canon in potential_path_starts_canon:
        # DFS: stack stores (current_net_canonical, current_ast_path_elements)
        # Start a new path exploration if the start_net hasn't been "consumed" in a significant way.
        # This check is tricky. We rely on components being marked `processed_components`.

        # Max depth to prevent infinite loops in cyclic graphs if not handled perfectly
        # This DFS aims to find ONE good path starting from start_net_canon.
        # If multiple paths emanate, they'll be explored when their respective components are hit.

        # Try to find a path starting from start_net_canon
        # Path element: {'type': 'node'/'component'/'source'/'parallel_block', ...}

        # This needs a recursive or iterative DFS helper function.
        # Simplified: For each component connected to start_net_canon, if it's a suitable
        # 2-terminal and unprocessed, try to build a path.

        # For each component connected to start_net_canon
        for comp_neighbor_name in list(graph.neighbors(start_net_canon)): # list() for safe iteration if modifying
            if comp_neighbor_name in processed_components or \
               graph.nodes[comp_neighbor_name].get('node_kind') != 'component_instance' or \
               comp_neighbor_name.startswith("_internal_"): # Internal ones are handled inside parallel blocks
                continue

            path_ast_elements = [{'type': 'node', 'name': get_preferred_net_name_for_reconstruction(start_net_canon, dsu, allow_implicit_if_only_option=True)}]

            # Try to build a path starting with comp_neighbor_name
            current_comp_in_path = comp_neighbor_name
            current_net_end_of_comp = start_net_canon # The net we are coming from for this component

            path_construction_possible = True
            temp_path_components = [] # Store components to mark processed if path is finalized

            while current_comp_in_path and path_construction_possible:
                if current_comp_in_path in processed_components: break # Stop if we hit an already processed component

                comp_type = comp_data_map[current_comp_in_path]['instance_type']
                comp_conns_map, _ = get_component_connectivity(graph, current_comp_in_path)

                # Check for parallel components between current_net_end_of_comp and some other_next_net
                # This is the tricky part: finding the "other side" of the parallel group.
                # For now, let's focus on simple series first, then add parallel.

                # --- Parallel Block Detection (Simplified) ---
                # Find all components connected to `current_net_end_of_comp`
                # For each such component, find the *other* net it connects to.
                # Group components that connect `current_net_end_of_comp` to the *same* `other_net_for_parallel`.

                potential_next_nets = {} # other_net_canon -> list of components connecting to it
                for comp_at_current_net in list(graph.neighbors(current_net_end_of_comp)):
                    if comp_at_current_net in processed_components or \
                       graph.nodes[comp_at_current_net].get('node_kind') != 'component_instance' or \
                       comp_at_current_net.startswith("_internal_"):
                        continue

                    # This component is a candidate for the current step (series or parallel)
                    # We need to find its "other end" from current_net_end_of_comp
                    # For a 2-terminal component:
                    inst_type = comp_data_map[comp_at_current_net]['instance_type']
                    c_conns, _ = get_component_connectivity(graph, comp_at_current_net)

                    other_net_for_this_comp = None
                    if len(c_conns) == 2: # Simple 2-terminal
                        nets_of_c = list(c_conns.values())
                        if nets_of_c[0] == current_net_end_of_comp: other_net_for_this_comp = nets_of_c[1]
                        elif nets_of_c[1] == current_net_end_of_comp: other_net_for_this_comp = nets_of_c[0]

                    if other_net_for_this_comp:
                        if other_net_for_this_comp not in potential_next_nets:
                            potential_next_nets[other_net_for_this_comp] = []
                        # Store component and its type for reconstruction
                        potential_next_nets[other_net_for_this_comp].append({
                            'name': comp_at_current_net,
                            'type': inst_type,
                            'conns_map': c_conns # To determine polarity for sources
                        })

                # Choose the next_net that has the most parallel components or a good path continuation
                # This is heuristic. For now, pick one other_net to proceed.
                # A better way: iterate over all potential_next_nets and try to form paths/blocks.

                chosen_next_net_canon = None
                components_for_this_step = [] # Can be single (series) or multiple (parallel)

                # Greedily pick a next hop. This needs to be smarter.
                # For now, let's simplify: if current_comp_in_path (which was `comp_neighbor_name` initially)
                # is a simple 2-terminal, try to use it for a series step.

                # --- Reverting to simpler series-only step for this iteration of the loop ---
                # (The parallel detection above needs to be integrated more cleanly)

                # Current component for this step of the path: `current_comp_in_path`
                comp_type = comp_data_map[current_comp_in_path]['instance_type']
                comp_conns_map, _ = get_component_connectivity(graph, current_comp_in_path)

                other_net_of_current_comp = None
                ast_element_for_current_comp = None

                if len(comp_conns_map) == 2: # Simple 2-terminal
                    nets_of_current_comp = list(comp_conns_map.values())
                    if nets_of_current_comp[0] == current_net_end_of_comp:
                        other_net_of_current_comp = nets_of_current_comp[1]
                    elif nets_of_current_comp[1] == current_net_end_of_comp:
                        other_net_of_current_comp = nets_of_current_comp[0]

                    if other_net_of_current_comp:
                        if comp_type in ["R", "C", "L"]:
                            ast_element_for_current_comp = {'type': 'component', 'name': current_comp_in_path}
                        elif comp_type in ["V", "I"]:
                            # Determine polarity: current_net_end_of_comp -- Polarity -- other_net_of_current_comp
                            # We need to find which terminal (pos/neg) is connected to current_net_end_of_comp
                            pol = ""
                            for term, net_c in comp_conns_map.items():
                                if net_c == current_net_end_of_comp:
                                    if term == 'pos': pol = '+-' # current_net is POSITIVE end
                                    elif term == 'neg': pol = '-+' # current_net is NEGATIVE end
                                    break
                            if pol:
                                ast_element_for_current_comp = {'type': 'source',
                                                              'name': current_comp_in_path,
                                                              'polarity': pol}
                            else: # Should not happen if graph is well-formed for V/I sources
                                path_construction_possible = False; continue
                        else: # Not a simple R,C,L,V,I - shouldn't be in this part of path building
                            path_construction_possible = False; continue
                else: # Not a 2-terminal component, path cannot extend with it in simple series
                    path_construction_possible = False; continue

                # If we have an element and its other net:
                if ast_element_for_current_comp and other_net_of_current_comp:
                    path_ast_elements.append(ast_element_for_current_comp)
                    temp_path_components.append(current_comp_in_path)

                    next_net_preferred_name = get_preferred_net_name_for_reconstruction(other_net_of_current_comp, dsu, allow_implicit_if_only_option=False) # Don't allow implicit as preferred end unless forced
                    is_next_net_significant_endpoint = not next_net_preferred_name.startswith('_implicit_')

                    if not remove_implicit_nodes and next_net_preferred_name.startswith('_implicit_'):
                         path_ast_elements.append({'type': 'node', 'name': next_net_preferred_name}) # Add explicit implicit node

                    current_net_end_of_comp = other_net_of_current_comp # Move to the other side

                    if is_next_net_significant_endpoint: # Path ends here with a significant node
                        path_ast_elements.append({'type': 'node', 'name': next_net_preferred_name})
                        if len(path_ast_elements) > 2: # Must have at least (N1) -- C1 -- (N2)
                             ast_statements.append({'type': 'series_connection', 'path': path_ast_elements})
                             for c in temp_path_components: processed_components.add(c)
                        path_construction_possible = False # End this path
                    else:
                        # Try to find next component from current_net_end_of_comp (which is other_net_of_current_comp)
                        found_next_comp_in_chain = False
                        for next_candidate_comp in list(graph.neighbors(current_net_end_of_comp)):
                            if graph.nodes[next_candidate_comp].get('node_kind') == 'component_instance' and \
                               next_candidate_comp not in processed_components and \
                               next_candidate_comp not in temp_path_components and \
                               not next_candidate_comp.startswith("_internal_"):
                                # Check if it's a 2-terminal component suitable for chaining
                                next_comp_conns, _ = get_component_connectivity(graph, next_candidate_comp)
                                if len(next_comp_conns) == 2: # Suitable for chaining
                                    current_comp_in_path = next_candidate_comp
                                    found_next_comp_in_chain = True
                                    break
                        if not found_next_comp_in_chain:
                            # Path ends here, potentially at an implicit node if not removing them
                            # or because no suitable unprocessed component found.
                            # If last added element was a component, add final node.
                            if path_ast_elements[-1]['type'] != 'node':
                                path_ast_elements.append({'type': 'node', 'name': get_preferred_net_name_for_reconstruction(current_net_end_of_comp, dsu, allow_implicit_if_only_option=True)})

                            if len(path_ast_elements) > 2:
                                ast_statements.append({'type': 'series_connection', 'path': path_ast_elements})
                                for c in temp_path_components: processed_components.add(c)
                            path_construction_possible = False # End this path attempt
                else:
                    path_construction_possible = False # Could not determine next step for current_comp_in_path

            # End of while current_comp_in_path loop

    # 4. Remaining 2-terminal components not in paths or complex blocks
    #    These might be single components between two (possibly implicit) named nodes.
    for comp_name in component_instance_nodes:
        if comp_name in processed_components or comp_name.startswith("_internal_"):
            continue

        instance_type = comp_data_map[comp_name]['instance_type']
        if instance_type in ["R", "C", "L", "V", "I"]: # Simple 2-terminal types
            comp_conns_map, _ = get_component_connectivity(graph, comp_name)
            if len(comp_conns_map) == 2:
                nets_of_comp = list(comp_conns_map.values())
                node1_preferred = get_preferred_net_name_for_reconstruction(nets_of_comp[0], dsu, allow_implicit_if_only_option=True)
                node2_preferred = get_preferred_net_name_for_reconstruction(nets_of_comp[1], dsu, allow_implicit_if_only_option=True)

                path_segment_ast = [{'type': 'node', 'name': node1_preferred}]
                if instance_type in ["V", "I"]:
                    pol = ""
                    for term, net_c in comp_conns_map.items():
                        if net_c == nets_of_comp[0]: # Node1 is this terminal
                            if term == 'pos': pol = '(+-)'
                            elif term == 'neg': pol = '(-+)'
                            break
                    if not pol: # Should determine based on standard terminal names
                        # Fallback if specific pos/neg not found directly, assume a default connection
                        # This means the graph representation for sources needs clear pos/neg terminals
                        # For now, if cannot determine polarity, emit as simple component
                         path_segment_ast.append({'type': 'component', 'name': comp_name})
                    else:
                        path_segment_ast.append({'type': 'source', 'name': comp_name, 'polarity': pol})
                else:
                    path_segment_ast.append({'type': 'component', 'name': comp_name})
                path_segment_ast.append({'type': 'node', 'name': node2_preferred})

                ast_statements.append({'type': 'series_connection', 'path': path_segment_ast})
                processed_components.add(comp_name)


    # 5. Final Direct Assignments for net aliases not covered
    if dsu:
        emitted_aliases = set()
        # First, collect all preferred names for each canonical net
        canonical_to_preferred_list = {}
        for canon_rep in dsu.get_all_canonical_representatives():
            preferred_name = get_preferred_net_name_for_reconstruction(canon_rep, dsu, allow_implicit_if_only_option=False)
            if not preferred_name.startswith("_implicit_"):
                 if canon_rep not in canonical_to_preferred_list:
                     canonical_to_preferred_list[canon_rep] = set()
                 canonical_to_preferred_list[canon_rep].add(preferred_name)

        all_user_nets_raw = [item for item in dsu.parent.keys() if not item.startswith("_implicit_")]
        for net_raw in all_user_nets_raw:
            canon = dsu.find(net_raw)
            pref_name_for_raw = get_preferred_net_name_for_reconstruction(net_raw, dsu, allow_implicit_if_only_option=False)

            # Get other preferred names for the same canonical net
            if canon in canonical_to_preferred_list:
                for other_pref_name in canonical_to_preferred_list[canon]:
                    if pref_name_for_raw != other_pref_name:
                        # Avoid (M1.G):(node_g) if M1{G:(node_g)} already exists
                        # This check is hard without cross-referencing the whole AST produced so far.
                        # A simple check: if one is a device terminal and the other isn't.
                        is_dev_term_alias = ('.' in pref_name_for_raw and '.' not in other_pref_name) or \
                                            ('.' not in pref_name_for_raw and '.' in other_pref_name)

                        # Heuristic: if it's not a device terminal aliasing to a plain name,
                        # or if both are plain names, it's a candidate.
                        # This is to reduce (M1.G): (node_gate) if M1 {G:(node_gate)} was already generated.

                        # More robust: check if this alias is already implied by a component_connection_block
                        implied_by_block = False
                        comp_name_of_terminal = None
                        terminal_itself = None

                        if '.' in pref_name_for_raw: comp_name_of_terminal, terminal_itself = pref_name_for_raw.split('.',1)
                        elif '.' in other_pref_name: comp_name_of_terminal, terminal_itself = other_pref_name.split('.',1)

                        if comp_name_of_terminal:
                            for stmt in ast_statements:
                                if stmt.get('type') == 'component_connection_block' and \
                                   stmt.get('component_name') == comp_name_of_terminal:
                                    for conn in stmt.get('connections', []):
                                        if conn.get('terminal') == terminal_itself:
                                            # If this terminal connects to the *other* preferred name of the alias
                                            if (conn.get('node') == pref_name_for_raw and '.' not in pref_name_for_raw) or \
                                               (conn.get('node') == other_pref_name and '.' not in other_pref_name):
                                                implied_by_block = True
                                                break
                                    if implied_by_block: break

                        pair = tuple(sorted((pref_name_for_raw, other_pref_name)))
                        if not implied_by_block and pair not in emitted_aliases:
                            ast_statements.append({
                                'type': 'direct_assignment',
                                'source_node': pref_name_for_raw,
                                'target_node': other_pref_name
                            })
                            emitted_aliases.add(pair)

    # Sort AST for consistent output
    def sort_key_final(stmt):
        if stmt['type'] == 'declaration': return (0, stmt.get('instance_name'))
        if stmt['type'] == 'component_connection_block': return (1, stmt.get('component_name'))
        if stmt['type'] == 'series_connection': # Sort by first node name in path
            first_node = stmt['path'][0]['name'] if stmt['path'] and stmt['path'][0]['type'] == 'node' else ''
            return (2, first_node, str(stmt['path'])) # Crude sort for series
        if stmt['type'] == 'direct_assignment': return (3, stmt.get('source_node'), stmt.get('target_node'))
        return (4,)
    ast_statements.sort(key=sort_key_final)

    return ast_statements

graph,dsu_map=(ast_to_graph(parsed_statements))
reconstructed_ast = graph_to_structured_ast(graph, dsu_map)
print(ProtoCircuitValidator(reconstructed_ast).validate())

reconstructed_code = generate_proto_from_ast(reconstructed_ast)

print(reconstructed_code)
parsed_statements, parser_errors = parser.parse_text(reconstructed_code)
print(parser_errors)
print(ProtoCircuitValidator(parsed_statements).validate())






